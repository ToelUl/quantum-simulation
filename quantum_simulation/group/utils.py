import torch
from itertools import combinations, product


def _commutator(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor:
    """Compute the commutator [A, B] = AB - BA of two matrices A and B.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).

    Returns:
        torch.Tensor: The commutator matrix of shape (..., N, N).
    """
    return a @ b - b @ a


def frob_inner(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor:
    """Compute the Frobenius inner product of two matrices A and B.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).

    Returns:
        torch.Tensor: The Frobenius inner product (scalar) of shape (...,).
    """
    assert a.dtype == b.dtype, "Input tensors must have the same dtype."
    if torch.is_complex(a) and torch.is_complex(b):
        return torch.einsum("...ij,...ij->...", a.conj(), b)
    else:
        return torch.einsum("...ij,...ij->...", a, b)


def structure_constants(g: torch.Tensor) -> torch.Tensor:
    """Compute the structure constants that make up the adjoint representation of a Lie algebra.
    [gamma, alpha, beta] = f_{gamma, alpha, beta} where [T_alpha, T_beta] = f_{gamma, alpha, beta} T_gamma.

    Args:
        g (torch.Tensor): A tensor of shape (d, N, N) representing the Lie algebra generators.

    Returns:
        torch.Tensor: The adjoint representation of shape (d, d, d),
        corresponding to indices (gamma, alpha, beta).
    """
    commutators = (torch.einsum("aik, bkj -> abij", g, g) -
                   torch.einsum("bik, akj -> abij", g, g))
    denominators = frob_inner(g, g)
    g_conj = g.conj() if torch.is_complex(g) else g
    numerators = torch.einsum("gij, abij -> gab", g_conj, commutators)
    structure_tensor = numerators / denominators.view(-1, 1, 1)

    return structure_tensor


def _is_orthogonal(a: torch.Tensor, b: torch.Tensor, tol: float = 1e-6) -> bool:
    """Check if two matrices A and B are orthogonal under the Frobenius inner product.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).
        tol (float): Tolerance for orthogonality check.

    Returns:
        bool: True if A and B are orthogonal, False otherwise.
    """
    inner_prod = frob_inner(a, b)
    return torch.allclose(inner_prod, torch.zeros_like(inner_prod), atol=tol)


@torch.no_grad()
def lie_closure_basis(
        generators: torch.Tensor,
        atol: float = 1e-6,
        rtol: float = 1e-5,
        max_iter: int = 10000, ) -> torch.Tensor:
    """
    Return an orthonormal Frobenius basis of the Lie algebra generated by `generators`.
    We add a matrix only if its residual (after projection to current span) has norm > tol.

    Args:
        generators (torch.Tensor): (M, N, N) real or complex tensors on CPU/GPU.
        atol (float): absolute tolerance for residual norm.
        rtol (float): relative tolerance (scaled by candidate norm).
        max_iter (int): safety cap on expansion rounds.

    Returns:
        torch.Tensor: (P, N, N) orthonormal basis tensors spanning the Lie algebra generated
        by the input `generators`.
    """
    assert generators.ndim == 3 and generators.shape[1] == generators.shape[2]

    # current orthonormal basis (Frobenius): list of (N,N) tensors
    Q = []

    def add_from_candidate(X: torch.Tensor) -> bool:
        """Project X onto span(Q), keep residual if significant; normalize then append."""
        # Skip near-zero candidate early
        xnorm = torch.linalg.norm(X)
        if xnorm <= atol:
            return False

        R = X
        for Qi in Q:
            alpha = frob_inner(Qi, R)
            R = R - alpha * Qi

        rnorm = torch.linalg.norm(R)
        # mixed absolute+relative criterion
        if rnorm > atol + rtol * xnorm:
            Q.append(R / rnorm)
            return True
        return False

    # 1) seed: orthonormalize the input set itself
    for A in generators:
        add_from_candidate(A)

    # 2) expand by commutators among the *current basis*
    added = True
    it = 0
    while added and it < max_iter:
        added = False
        k = len(Q)
        if k < 2:
            break
        Q_tensor = torch.stack(Q, dim=0)  # Shape: (k, N, N)

        all_comms = (torch.einsum("aik, bkj -> abij", Q_tensor, Q_tensor) -
                     torch.einsum("bik, akj -> abij", Q_tensor, Q_tensor))
        # all_comms Shape: (k, k, N, N)

        triu_indices = torch.triu_indices(k, k, offset=1, device=Q_tensor.device)
        # candidate_batch Shape: (k*(k-1)/2, N, N)
        candidate_batch = all_comms[triu_indices[0], triu_indices[1]]

        del all_comms, Q_tensor

        cnorms = torch.linalg.norm(candidate_batch, dim=(-2, -1))

        significant_indices = torch.where(cnorms > atol)[0]

        for idx in significant_indices:
            com = candidate_batch[idx]
            if add_from_candidate(com):
                added = True

        it += 1

        if len(Q) == generators.shape[1] ** 2:
            break

    # 3) stack; if nothing, return empty (0, N, N) on same device/dtype
    return torch.stack(Q, dim=0) if Q else generators[:0]


def coefficients_in_lie_closure_basis(target: torch.Tensor, basis: torch.Tensor) -> torch.Tensor:
    """
    Compute the coefficients of the target matrix in the given Lie algebra basis.

    Args:
        target (torch.Tensor): (..., N, N) target matrix.
        basis (torch.Tensor): (P, N, N) orthonormal basis tensors.

    Returns:
        torch.Tensor: (..., P) coefficients of the target in the basis.
    """
    return frob_inner(target.unsqueeze(-3), basis)


def check_cartan_decomp(
        g: torch.Tensor, k: torch.Tensor, m: torch.Tensor,
        atol: float = 1e-6, rtol: float = 1e-5) -> bool:
    """
    Check if the given decomposition g = k + m satisfies the Cartan decomposition properties:
    [k, k] ⊆ k, [k, m] ⊆ m, [m, m] ⊆ k.

    Args:
        g (torch.Tensor): (N, N, N) tensor of Lie algebra basis elements.
        k (torch.Tensor): (K, N, N) tensor of vertical subspace k basis elements.
        m (torch.Tensor): (M, N, N) tensor of horizontal subspace m basis elements.
        atol (float): absolute tolerance for checking inclusion.
        rtol (float): relative tolerance for checking inclusion.

    Returns:
        bool: True if the decomposition satisfies the Cartan properties, False otherwise.
    """
    # Check Lie closure of k
    k_lie_closure = lie_closure_basis(k, atol=atol, rtol=rtol)
    k_is_closed = k_lie_closure.shape[0] == k.shape[0]
    print(f"The Lie closure of k is as big as k itself: {k_is_closed}.")

    # Check the dimension
    dim_g, dim_k, dim_m = g.shape[0], k.shape[0], m.shape[0]
    dim_check = dim_g == dim_k + dim_m
    print(f"Dimension check g = k + m holds: {dim_check} ({dim_g} = {dim_k} + {dim_m}).")

    # Check reductive property [k, m] ⊆ m
    km_commutators = [_commutator(k_op, m_op) for k_op, m_op in product(torch.unbind(k), torch.unbind(m))]
    km_comm_in_m = all([_is_orthogonal(com, k, tol=atol) for com in km_commutators])
    print(f"Reductive property [k, m] ⊆ m (orthogonal to k) holds: {km_comm_in_m}.")
    if km_comm_in_m:
        print("G/K is a reductive homogeneous space.")

    # Check symmetric property [m, m] ⊆ k
    mm_commutators = [_commutator(m1, m2) for m1, m2 in combinations(torch.unbind(m), 2)]
    mm_comm_in_k = all([_is_orthogonal(com, m, tol=atol) for com in mm_commutators])
    print(f"Symmetric property [m, m] ⊆ k (orthogonal to m) holds: {mm_comm_in_k}.")

    return k_is_closed and dim_check and km_comm_in_m and mm_comm_in_k
