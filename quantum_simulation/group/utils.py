import torch
from itertools import combinations, product


def _commutator(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor:
    """Compute the commutator [A, B] = AB - BA of two matrices A and B.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).

    Returns:
        torch.Tensor: The commutator matrix of shape (..., N, N).
    """
    return a @ b - b @ a


def frob_inner(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor:
    """Compute the Frobenius inner product of two matrices A and B.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).

    Returns:
        torch.Tensor: The Frobenius inner product (scalar) of shape (...,).
    """
    if torch.is_complex(a) or torch.is_complex(b):
        return torch.einsum("...ij,...ij->...", a.conj(), b)
    else:
        return torch.einsum("...ij,...ij->...", a, b)


def structure_constants(g: torch.Tensor) -> torch.Tensor:
    """Compute the structure constants that make up the adjoint representation of a Lie algebra.
    [gamma, alpha, beta] = f_{gamma, alpha, beta} where [T_alpha, T_beta] = f_{gamma, alpha, beta} T_gamma.

    Args:
        g (torch.Tensor): A tensor of shape (d, N, N) representing the Lie algebra generators.

    Returns:
        torch.Tensor: The adjoint representation of shape (d, d, d),
        corresponding to indices (gamma, alpha, beta).
    """
    structure_tensor = torch.zeros(g.shape[0], g.shape[0], g.shape[0], dtype=g.dtype, device=g.device)
    index_list = list(range(g.shape[0]))
    for gamma, alpha, beta in product(index_list, repeat=3):
        structure_tensor[gamma, alpha, beta] = (frob_inner(g[gamma], _commutator(g[alpha], g[beta]))
                                                / frob_inner(g[gamma], g[gamma]))
    return structure_tensor


def _is_orthogonal(a: torch.Tensor, b: torch.Tensor, tol: float = 1e-6) -> bool:
    """Check if two matrices A and B are orthogonal under the Frobenius inner product.

    Args:
        a (torch.Tensor): First input matrix of shape (..., N, N).
        b (torch.Tensor): Second input matrix of shape (..., N, N).
        tol (float): Tolerance for orthogonality check.

    Returns:
        bool: True if A and B are orthogonal, False otherwise.
    """
    inner_prod = frob_inner(a, b)
    return torch.allclose(inner_prod, torch.zeros_like(inner_prod), atol=tol)


@torch.no_grad()
def lie_closure_basis(
    generators: torch.Tensor,
    atol: float = 1e-6,
    rtol: float = 1e-5,
    max_iter: int = 10000,
) -> torch.Tensor:
    """
    Return an orthonormal Frobenius basis of the Lie algebra generated by `generators`.
    We add a matrix only if its residual (after projection to current span) has norm > tol.

    Args:
        generators (torch.Tensor): (M, N, N) real or complex tensors on CPU/GPU.
        atol (float): absolute tolerance for residual norm.
        rtol (float): relative tolerance (scaled by candidate norm).
        max_iter (int): safety cap on expansion rounds.

    Returns:
        torch.Tensor: (P, N, N) orthonormal basis tensors spanning the Lie algebra generated
        by the input `generators`.
    """
    assert generators.ndim == 3 and generators.shape[1] == generators.shape[2]

    # current orthonormal basis (Frobenius): list of (N,N) tensors
    Q = []

    def add_from_candidate(X: torch.Tensor) -> bool:
        """Project X onto span(Q), keep residual if significant; normalize then append."""
        # Skip near-zero candidate early
        xnorm = torch.linalg.norm(X)
        if xnorm <= atol:
            return False

        R = X
        for Qi in Q:
            alpha = frob_inner(Qi, R)
            R = R - alpha * Qi

        rnorm = torch.linalg.norm(R)
        # mixed absolute+relative criterion
        if rnorm > atol + rtol * xnorm:
            Q.append(R / rnorm)
            return True
        return False

    # 1) seed: orthonormalize the input set itself
    for A in generators:
        add_from_candidate(A)

    # 2) expand by commutators among the *current basis* (sufficient by bilinearity)
    added = True
    it = 0
    while added and it < max_iter:
        added = False
        for A, B in combinations(Q, 2):
            com = _commutator(A, B)
            # discard exact/near-zero commutators quickly
            cnorm = torch.linalg.norm(com)
            if cnorm <= atol:
                continue
            if add_from_candidate(com):
                added = True
        it += 1

    # 3) stack; if nothing, return empty (0, N, N) on same device/dtype
    return torch.stack(Q, dim=0) if Q else generators[:0]


def check_cartan_decomp(
        g: torch.Tensor, k: torch.Tensor, m: torch.Tensor,
        atol: float = 1e-6, rtol: float = 1e-5) -> bool:
    """
    Check if the given decomposition g = k + m satisfies the Cartan decomposition properties:
    [k, k] ⊆ k, [k, m] ⊆ m, [m, m] ⊆ k.

    Args:
        g (torch.Tensor): (N, N, N) tensor of Lie algebra basis elements.
        k (torch.Tensor): (K, N, N) tensor of vertical subspace k basis elements.
        m (torch.Tensor): (M, N, N) tensor of horizontal subspace m basis elements.
        atol (float): absolute tolerance for checking inclusion.
        rtol (float): relative tolerance for checking inclusion.

    Returns:
        bool: True if the decomposition satisfies the Cartan properties, False otherwise.
    """
    # Check Lie closure of k
    k_lie_closure = lie_closure_basis(k, atol=atol, rtol=rtol)
    k_is_closed = k_lie_closure.shape[0] == k.shape[0]
    print(f"The Lie closure of k is as big as k itself: {k_is_closed}.")

    # Check the dimension
    dim_g, dim_k, dim_m = g.shape[0], k.shape[0], m.shape[0]
    dim_check = dim_g == dim_k + dim_m
    print(f"Dimension check g = k + m holds: {dim_check} ({dim_g} = {dim_k} + {dim_m}).")

    # Check reductive property [k, m] ⊆ m
    km_commutators = [_commutator(k_op, m_op) for k_op, m_op in product(torch.unbind(k), torch.unbind(m))]
    km_comm_in_m = all([_is_orthogonal(com, k, tol=atol) for com in km_commutators])
    print(f"Reductive property [k, m] ⊆ m (orthogonal to k) holds: {km_comm_in_m}.")
    if km_comm_in_m:
        print("G/K is a reductive homogeneous space.")

    # Check symmetric property [m, m] ⊆ k
    mm_commutators = [_commutator(m1, m2) for m1, m2 in combinations(torch.unbind(m), 2)]
    mm_comm_in_k = all([_is_orthogonal(com, m, tol=atol) for com in mm_commutators])
    print(f"Symmetric property [m, m] ⊆ k (orthogonal to m) holds: {mm_comm_in_k}.")

    return k_is_closed and dim_check and km_comm_in_m and mm_comm_in_k
